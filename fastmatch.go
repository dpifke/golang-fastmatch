// Copyright (c) 2014-2016 Dave Pifke.
//
// Redistribution and use in source and binary forms, with or without
// modification, is permitted provided that the following conditions are met:
//
// 1. Redistributions of source code must retain the above copyright notice,
//    this list of conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//    and/or other materials provided with the distribution.
//
// 3. Neither the name of the copyright holder nor the names of its
//    contributors may be used to endorse or promote products derived from
//    this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

/*
Package fastmatch provides a code generation tool for quickly comparing an
input string to a set of possible matches, which are known at compile time.
The canonical example would be a "reverse enum", such as in a parser which
needs to compare a string to a list of keywords and return the corresponding
constant.

The easiest way to do this is with a switch statement, such as:

	switch (input) {
	case "foo":
		return foo
	case "bar":
		return bar
	case "baz":
		return baz
	}

Under the hood, the compiled code for the above will compare the input to each
string in sequence.  If input doesn't match "foo", we try to match "bar", then
"baz".  The matching process starts anew for each case.  If we have lots of
possible matches, this can be a lot of wasted effort.

Another option would be to use a map, on the (probably valid) assumption that
Go's map lookups are faster than executing a bunch of string comparisons in
sequence:

	match := map[string]int{
		"foo": foo,
		"bar": bar,
		"baz": baz,
	}
	return match[input]

As far as I can tell, the compiled code for the above will recreate the map at
runtime.  We thus have to hash each possible match every time the map is
initialized, allocate memory, garbage collect it, etc.  More wasted effort.

You could also use a regular expression, but now you'd have two problems, as
the jwz quote goes.

The code generated by this package is slightly more efficient than the
preceding approaches.  It partitions the search space by the length of the
input string, then updates a state machine based on each rune in the input.
If the character at a given position in the input doesn't correspond to any
possible match, we bail early.  Otherwise, the final state is compared against
possible matches using a final switch statement.

Is the code output by this package faster enough to matter?  Maybe, maybe not.
This is a straight port of a C code generation tool I've used on a couple of
projects.  In C, the difference was significant, due to strcmp() function call
overhead and GCC's ability to convert long switch statements into jump tables
or binary searches.  In Go, the difference is probably less noticeable.

This probably isn't the tool to use if your possible matches are very long or
you have a ridiculous number of them, since the state machine counter has to
fit within a uint64.  It will panic at code generation time if this limit is
exceeded.

*/
package fastmatch

import (
	"fmt"
	"io"
	"math"
	"sort"
	"strings"
	"unicode"
)

type flag int

const (
	Insensitive flag = iota
	Normalize
)

type sortableRunes []rune

func (r sortableRunes) Len() int           { return len(r) }
func (r sortableRunes) Swap(a, b int)      { r[a], r[b] = r[b], r[a] }
func (r sortableRunes) Less(a, b int) bool { return r[a] < r[b] }

// Generate outputs Go code to compare a string to a set of possible matches
// which are known at compile-time.
//
// Each entry in the map consists of a possible match as the key, and the
// corresponding expression to return as the value.  none is the expression to
// return if no match is found.
//
// Code to perform the match is written to the supplied io.Writer.  Before
// calling this function, the caller is expected to write the method signature
// and any input pre-processing logic.  The string to examine should be in a
// variable named "input".
//
// If the Insensitive flag is supplied, the comparison will be
// case-insensitive.  The Normalize flag indicates Unicode characters should
// be normalized (for instance by ignoring diacritics), but this functionality
// is not yet implemented.
//
// Example usage:
//
//	w.Write([]byte("func matchFoo(input string) int {\n"))
//	fastmatch.Generate(w, map[string]string{
//		"foo": "1",
//		"bar": "2",
//		"baz": "3",
//	}, "-1", fastmatch.Insensitive)
func Generate(w io.Writer, cases map[string]string, none string, flags ...flag) {
	var insensitive, normalize bool
	for _, flag := range flags {
		switch flag {
		case Insensitive:
			insensitive = true
		case Normalize:
			normalize = true
		}
	}
	_ = normalize // TODO: someday we'll support unicode normalization

	// Search is partitioned based on the length of the input.  Split
	// cases into each possible search space.
	keys := make(map[int][]string)
	for key := range cases {
		if insensitive {
			key = strings.ToLower(key)
		}
		keys[len(key)] = append(keys[len(key)], key)
	}
	lengths := make([]int, 0, len(keys))
	for len := range keys {
		lengths = append(lengths, len)
	}
	sort.Ints(lengths)

	fmt.Fprint(w, "\tswitch len(input) {\n")
	for _, l := range lengths {
		fmt.Fprintf(w, "\tcase %d:\n", l)
		fmt.Fprint(w, "\t\tvar state uint64\n")

		// State machine housekeeping.  There's a unique state machine
		// for each search space.
		next := uint64(1)
		var base uint64
		final := make(map[string][]uint64, len(keys[l]))
		for _, key := range keys[l] {
			final[key] = make([]uint64, len(key))
		}

		for offset := 0; offset < l; offset++ {
			// Make a sorted list (sans duplicates) of possible
			// runes at this offset:
			runes := sortableRunes(make([]rune, 0, len(keys[l])))
			runesSeen := make(map[rune]bool, len(keys[l]))
			for _, key := range keys[l] {
				r := rune(key[offset])
				if !runesSeen[r] {
					runes = append(runes, r)
					runesSeen[r] = true
				}
			}
			sort.Sort(runes)

			// Assign a unique state value to each possible rune,
			// and track the relationship between state values and
			// matches:
			base = next
			states := make(map[rune]uint64, len(keys[l]))
			for _, r := range runes {
				states[r] = next
				for _, key := range keys[l] {
					if rune(key[offset]) == r {
						final[key][offset] = next
					}
				}
				if base > math.MaxUint64-next {
					panic("too many values to match!  uint64 overflow!")
				}
				next += base
			}

			// Output code which increments state based on which
			// rune was seen:
			fmt.Fprintf(w, "\t\tswitch input[%d] {\n", offset)
			for _, r := range runes {
				fmt.Fprintf(w, "\t\tcase '%c'", r)
				if insensitive && unicode.IsLower(r) {
					fmt.Fprintf(w, ", '%c'", unicode.ToUpper(r))
				}
				fmt.Fprint(w, ":\n")
				fmt.Fprintf(w, "\t\t\tstate += 0x%x\n", states[r])
			}
			fmt.Fprint(w, "\t\tdefault:\n")
			fmt.Fprintf(w, "\t\t\treturn %s\n", none)
			fmt.Fprintf(w, "\t\t}\n")
		}

		// Now output code to compare actual state to possible final
		// values:
		fmt.Fprintf(w, "\t\tswitch state {\n")
		for _, key := range keys[l] {
			fmt.Fprint(w, "\t\tcase ")
			for i, state := range final[key] {
				if i != 0 {
					fmt.Fprintf(w, " + ")
				}
				fmt.Fprintf(w, "0x%x", state)
			}
			fmt.Fprint(w, ":\n")
			fmt.Fprint(w, "\t\t\treturn ", cases[key], "\n")
		}
		fmt.Fprintf(w, "\t\t}\n")
	}
	fmt.Fprint(w, "\t}\n")
	fmt.Fprintf(w, "\treturn %s\n", none)
	fmt.Fprint(w, "}\n")
}
