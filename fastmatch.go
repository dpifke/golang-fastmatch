// Copyright (c) 2014-2016 Dave Pifke.
//
// Redistribution and use in source and binary forms, with or without
// modification, is permitted provided that the following conditions are met:
//
// 1. Redistributions of source code must retain the above copyright notice,
//    this list of conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//    and/or other materials provided with the distribution.
//
// 3. Neither the name of the copyright holder nor the names of its
//    contributors may be used to endorse or promote products derived from
//    this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

/*
Package fastmatch provides a code generation tool for quickly comparing an
input string to a set of possible matches, which are known at compile time.
The canonical example would be a "reverse enum", such as in a parser which
needs to compare a string to a list of keywords and return the corresponding
constant.

The easiest way to do this is with a switch statement, such as:

	switch (input) {
	case "foo":
		return foo
	case "bar":
		return bar
	case "baz":
		return baz
	}

Under the hood, the compiled code for the above will compare the input to each
string in sequence.  If input doesn't match "foo", we try to match "bar", then
"baz".  The matching process starts anew for each case.  If we have lots of
possible matches, this can be a lot of wasted effort.

Another option would be to use a map, on the (probably valid) assumption that
Go's map lookups are faster than executing a bunch of string comparisons in
sequence:

	match := map[string]int{
		"foo": foo,
		"bar": bar,
		"baz": baz,
	}
	return match[input]

As far as I can tell, the compiled code for the above will recreate the map at
runtime.  We thus have to hash each possible match every time the map is
initialized, allocate memory, garbage collect it, etc.  More wasted effort.

You could also use a regular expression, but now you'd have two problems, as
the jwz quote goes.

The code generated by this package is slightly more efficient than the
preceding approaches.  It partitions the search space by the length of the
input string, then updates a state machine based on each rune in the input.
If the character at a given position in the input doesn't correspond to any
possible match, we bail early.  Otherwise, the final state is compared against
possible matches using a final switch statement.

Is the code output by this package faster enough to matter?  Maybe, maybe not.
This is a straight port of a C code generation tool I've used on a couple of
projects.  In C, the difference was significant, due to strcmp() function call
overhead and GCC's ability to convert long switch statements into jump tables
or binary searches.  In Go, the difference is probably less noticeable.

This probably isn't the tool to use if your possible matches are very long or
you have a ridiculous number of them, since the state machine counter has to
fit within a uint64.  It will return an error at code generation time if this
limit is exceeded.

*/
package fastmatch

import (
	"errors"
	"fmt"
	"io"
	"math"
	"sort"
	"strconv"
)

type flag struct {
	equivalent []rune
}

// Insensitive is a flag, which can be passed to Generate, to specify that
// matching should be case-insensitive.
var Insensitive = new(flag)

// Normalize is a flag, which can be passed to Generate, to specify that
// matching should be done without regard to diacritics, accents, etc.
//
// This is not currently implemented.
var Normalize = new(flag)

// Equivalent is a flag, which can be passed to Generate, to specify
// runes that should be treated identically when matching.
func Equivalent(runes ...rune) *flag {
	return &flag{equivalent: runes}
}

// sortableRunes implements sort.Sortable on a slice of runes.
type sortableRunes []rune

func (r sortableRunes) Len() int           { return len(r) }
func (r sortableRunes) Swap(a, b int)      { r[a], r[b] = r[b], r[a] }
func (r sortableRunes) Less(a, b int) bool { return r[a] < r[b] }

// runeEquivalents holds our map of which runes are equivalent to each other.
type runeEquivalents map[rune]sortableRunes

// dedupedRuneEquivalents is used internally in the construction of
// runeEquivalents.
type dedupedRuneEquivalents map[rune]map[rune]bool

// set adds a rune key and value to dedupedRuneEquivalents, calling make() on
// the second-level map as needed.
func (equiv dedupedRuneEquivalents) set(r1, r2 rune) {
	if _, exists := equiv[r1]; !exists {
		equiv[r1] = make(map[rune]bool, 2)
		equiv[r1][r1] = true
	}
	equiv[r1][r2] = true
}

// collapse converts dedupedRuneEquivalents to runeEquivalents.
func (equiv dedupedRuneEquivalents) collapse() runeEquivalents {
	newEquiv := make(runeEquivalents, len(equiv))
	for r1, rm := range equiv {
		newEquiv[r1] = make(sortableRunes, 0, len(rm))
		for r2 := range rm {
			newEquiv[r1] = append(newEquiv[r1], r2)
		}
		sort.Sort(newEquiv[r1])
	}
	return newEquiv
}

// makeRuneEquivalents builds our rune equivalence map based on flags.
func makeRuneEquivalents(flags ...*flag) runeEquivalents {
	equiv := make(dedupedRuneEquivalents)

	for _, f := range flags {
		if f == Insensitive {
			for lower := 'a'; lower <= 'z'; lower++ {
				upper := 'A' + (lower - 'a')
				equiv.set(lower, upper)
				equiv.set(upper, lower)
			}
		} else if f == Normalize {
			continue // TODO: not yet implemented
		} else if len(f.equivalent) > 0 {
			for _, i := range f.equivalent {
				for _, j := range f.equivalent {
					equiv.set(i, j)
				}
			}
		}
	}

	return equiv.collapse()
}

// lookup returns a map entry from runeEquivalents, defaulting to a slice
// containing just the lookup key if there are no equivalents for that rune.
func (equiv runeEquivalents) lookup(r rune) []rune {
	if rs, found := equiv[r]; found {
		return rs
	} else {
		return []rune{r}
	}
}

// Generate outputs Go code to compare a string to a set of possible matches
// which are known at compile-time.
//
// Each entry in the map consists of a possible match as the key, and the
// corresponding expression to return as the value.  none is the expression to
// return if no match is found.
//
// Code to perform the match is written to the supplied io.Writer.  Before
// calling this function, the caller is expected to write the method signature
// and any input pre-processing logic.  The string to examine should be in a
// variable named "input".
//
// Example usage:
//
//	fmt.Fprintln(w, "func matchFoo(input string) int {")
//	fastmatch.Generate(w, map[string]string{
//		"foo": "1",
//		"bar": "2",
//		"baz": "3",
//	}, "-1", fastmatch.Insensitive)
func Generate(w io.Writer, cases map[string]string, none string, flags ...*flag) error {
	equiv := makeRuneEquivalents(flags...)

	// Search is partitioned based on the length of the input.  Split
	// cases into each possible search space.
	keys := make(map[int][]string)
	for key := range cases {
		keys[len(key)] = append(keys[len(key)], key)
	}
	lengths := make([]int, 0, len(keys))
	for len := range keys {
		lengths = append(lengths, len)
	}
	sort.Ints(lengths)

	if _, err := fmt.Fprintln(w, "\tswitch len(input) {"); err != nil {
		return err
	}
	for _, l := range lengths {
		fmt.Fprintf(w, "\tcase %d:", l)
		fmt.Fprintln(w)
		fmt.Fprintln(w, "\t\tvar state uint64")

		// State machine housekeeping.  There's a unique state machine
		// for each search space.
		next := uint64(1)
		var base uint64
		final := make(map[string][]uint64, len(keys[l]))
		for _, key := range keys[l] {
			final[key] = make([]uint64, len(key))
		}

		for offset := 0; offset < l; offset++ {
			// Make a sorted list (sans duplicates) of possible
			// runes at this offset:
			runes := sortableRunes(make([]rune, 0, len(keys[l])))
			runesSeen := make(map[rune]bool, len(keys[l]))
		possibilities:
			for _, key := range keys[l] {
				r := rune(key[offset])
				for _, r2 := range equiv.lookup(r) {
					if runesSeen[r2] {
						continue possibilities
					}
					runesSeen[r2] = true
				}
				runes = append(runes, r)
			}
			sort.Sort(runes)

			// Assign a unique state value to each possible rune
			// (including equivalents), and track the relationship
			// between state values and matches:
			base = next
			states := make(map[rune]uint64, len(keys[l]))
			for _, r := range runes {
				states[r] = next
				for _, key := range keys[l] {
					for _, r2 := range equiv.lookup(r) {
						if rune(key[offset]) == r2 {
							final[key][offset] = next
							break
						}
					}
				}
				if base > math.MaxUint64-next {
					return errors.New("too many values to match!  uint64 overflow!")
				}
				next += base
			}

			// Output code which increments state based on which
			// rune (or equivalent) was seen:
			fmt.Fprintf(w, "\t\tswitch input[%d] {", offset)
			fmt.Fprintln(w)
			for _, r := range runes {
				fmt.Fprint(w, "\t\tcase ")
				for n, r2 := range equiv.lookup(r) {
					if n != 0 {
						fmt.Fprint(w, ", ")
					}
					fmt.Fprintf(w, "'%c'", r2)
				}
				fmt.Fprintln(w, ":")
				fmt.Fprintf(w, "\t\t\tstate += 0x%x", states[r])
				fmt.Fprintln(w)
			}
			fmt.Fprintln(w, "\t\tdefault:")
			fmt.Fprintln(w, "\t\t\treturn", none)
			fmt.Fprintln(w, "\t\t}")
		}

		// Now output code to compare actual state to possible final
		// values:
		fmt.Fprintln(w, "\t\tswitch state {")
		for _, key := range keys[l] {
			fmt.Fprint(w, "\t\tcase ")
			for n, state := range final[key] {
				if n != 0 {
					fmt.Fprintf(w, " + ")
				}
				fmt.Fprintf(w, "0x%x", state)
			}
			fmt.Fprintln(w, ":")
			fmt.Fprintln(w, "\t\t\treturn", cases[key])
		}
		fmt.Fprintln(w, "\t\t}")
	}
	fmt.Fprintln(w, "\t}")
	fmt.Fprintln(w, "\treturn", none)
	fmt.Fprintln(w, "}")

	return nil
}

// GenerateReverse outputs Go code that returns the string value for a given
// match.  The result from the generated function will be the reverse of that
// from a function generated with Generate.
//
// If more than one string maps to the same value, the code generated by this
// function will not be valid.
//
// This function accepts flags (in order to match Generate's function
// signature), but they are currently ignored.
func GenerateReverse(w io.Writer, cases map[string]string, none string, _ ...*flag) error {
	keys := make([]string, 0, len(cases))
	for key := range cases {
		keys = append(keys, key)
	}
	sort.Strings(keys)

	if _, err := fmt.Fprintln(w, "\tswitch input {"); err != nil {
		return err
	}
	for _, key := range keys {
		fmt.Fprintf(w, "\tcase %s:", cases[key])
		fmt.Fprintln(w)
		fmt.Fprintln(w, "\t\treturn", strconv.Quote(key))
	}
	fmt.Fprintln(w, "\tdefault:")
	fmt.Fprintln(w, "\t\treturn", none)
	fmt.Fprintln(w, "\t}")
	fmt.Fprintln(w, "}")

	return nil
}
