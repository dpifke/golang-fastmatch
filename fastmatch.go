// Copyright (c) 2014-2016 Dave Pifke.
//
// Redistribution and use in source and binary forms, with or without
// modification, is permitted provided that the following conditions are met:
//
// 1. Redistributions of source code must retain the above copyright notice,
//    this list of conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//    and/or other materials provided with the distribution.
//
// 3. Neither the name of the copyright holder nor the names of its
//    contributors may be used to endorse or promote products derived from
//    this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

/*
Package fastmatch provides a code generation tool for quickly comparing an
input string to a set of possible matches, which are known at compile time.

A typical use of this would be a "reverse enum", such as in a parser which
needs to compare a string to a list of keywords and return the corresponding
lexer symbol.

The easiest way to do this is with a switch statement, such as:

	switch (input) {
	case "foo":
		return foo
	case "bar":
		return bar
	case "baz":
		return baz
	}

Under the hood, the compiled code for the above will compare the input to each
string in sequence.  If input doesn't match "foo", we try to match "bar", then
"baz".  The matching process starts anew for each case.  If we have lots of
possible matches, this can be a lot of wasted effort.

Another option would be to use a map, on the (probably valid) assumption that
Go's map lookups are faster than executing a bunch of string comparisons in
sequence:

	match := map[string]int{
		"foo": foo,
		"bar": bar,
		"baz": baz,
	}
	return match[input]

As far as I can tell, the compiled code for the above will recreate the map at
runtime.  We thus have to hash each possible match every time the map is
initialized, allocate memory, garbage collect it, etc.  More wasted effort.

You could also use a regular expression, but now you'd have two problems, as
the jwz quote goes.

Not to mention the potential complications related to case-insensitive
matching, Unicode normalization, or situations where we want to treat a class
of characters (such as all numeric digits) as equivalent for matching
purposes.

The code generated by this package is slightly more efficient than the
preceding approaches, and it can treat groups of characters (e.g. 'a' and 'A')
as equivalent.  It partitions the search space by the length of the input
string, then updates a state machine based on each rune in the input.  If the
character at a given position in the input doesn't correspond to any possible
match, we bail early.  Otherwise, the final state is compared against possible
matches using a final switch statement.

Is the code output by this package faster enough to matter?  Maybe, maybe not.
This is a straight port of a C code generation tool I've used on a couple of
projects.  In C, the difference was significant, due to strcmp() or
strcasecmp() function call overhead, and GCC's ability to convert long switch
statements into jump tables or binary searches.  In Go, the speed difference
is probably less noticeable.

This probably isn't the right tool to use if your possible matches are longer
than short words or phrases, or if you have a ridiculous number of them, since
the state machine counter has to fit within a uint64.  It will return an error
at code generation time if this limit is exceeded.
*/
package fastmatch

import (
	"bytes"
	"errors"
	"fmt"
	"io"
	"math"
	"sort"
	"strconv"
)

type flag struct {
	equivalent []rune
}

// Insensitive is a flag, which can be passed to Generate, to specify that
// matching should be case-insensitive.
var Insensitive = new(flag)

// Normalize is a flag, which can be passed to Generate, to specify that
// matching should be done without regard to diacritics, accents, etc.
//
// This is currently just a placeholder, and has no effect yet on the
// generated code.
var Normalize = new(flag)

// Equivalent is a flag, which can be passed to Generate, to specify
// runes that should be treated identically when matching.
func Equivalent(runes ...rune) *flag {
	return &flag{equivalent: runes}
}

// sortableRunes implements sort.Sortable on a slice of runes.
type sortableRunes []rune

func (r sortableRunes) Len() int           { return len(r) }
func (r sortableRunes) Swap(a, b int)      { r[a], r[b] = r[b], r[a] }
func (r sortableRunes) Less(a, b int) bool { return r[a] < r[b] }

// runeEquivalents holds our map of which runes are equivalent to each other.
type runeEquivalents map[rune]sortableRunes

// dedupedRuneEquivalents is used internally in the construction of
// runeEquivalents.
type dedupedRuneEquivalents map[rune]map[rune]bool

// set adds a rune key and zero or more values to dedupedRuneEquivalents,
// calling make() on the second-level map as needed.
func (equiv dedupedRuneEquivalents) set(r rune, rs ...rune) {
	if _, exists := equiv[r]; !exists {
		equiv[r] = make(map[rune]bool, len(rs)+1)
		equiv[r][r] = true
	}
	for _, r2 := range rs {
		equiv[r][r2] = true
	}
}

// collapse converts dedupedRuneEquivalents to runeEquivalents.
func (equiv dedupedRuneEquivalents) collapse() runeEquivalents {
	newEquiv := make(runeEquivalents, len(equiv))
	for r1, rm := range equiv {
		// If equiv['a'] contains 'b', and equiv['b'] contains 'c', we
		// want to ensure 'c' is present in equiv['a'].  This requires
		// several passes, until we've determined the transitive
		// equivalence of every rune therein.
		seen := make(map[rune]bool, len(rm))
	populateTransience:
		for {
			for r2 := range rm {
				if seen[r2] {
					continue
				}
				for r3 := range equiv[r2] {
					equiv[r1][r3] = true
				}
				seen[r2] = true
				continue populateTransience
			}
			break
		}

		// Now we can convert from map[rune]bool to sorted []rune.
		newEquiv[r1] = make(sortableRunes, 0, len(rm))
		for r2 := range rm {
			newEquiv[r1] = append(newEquiv[r1], r2)
		}
		sort.Sort(newEquiv[r1])
	}
	return newEquiv
}

// makeRuneEquivalents builds our rune equivalence map based on flags.
func makeRuneEquivalents(flags ...*flag) runeEquivalents {
	equiv := make(dedupedRuneEquivalents)

	for _, f := range flags {
		if f == Insensitive {
			for lower := 'a'; lower <= 'z'; lower++ {
				upper := 'A' + (lower - 'a')
				equiv.set(lower, upper)
				equiv.set(upper, lower)
			}
		} else if f == Normalize {
			continue // TODO: not yet implemented
		} else if len(f.equivalent) > 0 {
			for _, r := range f.equivalent {
				equiv.set(r, f.equivalent...)
			}
		} else {
			// Shouldn't be reachable if package exports are
			// honored, since flag is package-private:
			panic("unknown flag")
		}
	}

	return equiv.collapse()
}

// lookup returns a map entry from runeEquivalents, defaulting to a slice
// containing just the lookup key if there are no equivalents for that rune.
func (equiv runeEquivalents) lookup(r rune) []rune {
	if rs, found := equiv[r]; found {
		return rs
	} else {
		return []rune{r}
	}
}

// stateMachine holds the mapping between a match and the intermediate state
// changes (runes encountered) leading up to a match.
type stateMachine struct {
	next  uint64
	base  uint64
	final map[string][]uint64
}

// newStateMachine initializes a stateMachine.
func newStateMachine(keys []string) *stateMachine {
	state := &stateMachine{
		next:  1,
		base:  1,
		final: make(map[string][]uint64, len(keys)),
	}
	for _, key := range keys {
		state.final[key] = make([]uint64, 0, len(key))
	}
	return state
}

// accumulate specifies that the current intermediate state should be
// encountered when matching key.
func (state *stateMachine) accumulate(key string) {
	state.final[key] = append(state.final[key], state.next)
}

// shift should be called at each new position, to ensure new intermediate
// state values do not overlap with previous ones.
func (state *stateMachine) shift() {
	state.base = state.next
}

// increment creates a new intermediate state.  It returns an error if we have
// too many intermediate states to fit in a uint64.
func (state *stateMachine) increment() error {
	if state.base > math.MaxUint64-state.next {
		return errors.New("too many values to match: uint64 overflow!")
	}
	state.next += state.base
	return nil
}

// checkAmbiguity verifies there is exactly one possible return value for each
// final state, returning an error if any matches are ambiguous.
func (state *stateMachine) checkAmbiguity(cases map[string]string) error {
	// map[final state] -> map[return value] -> []keys
	ambiguity := make(map[uint64]map[string][]string, len(cases))
	for key, values := range state.final {
		var sum uint64
		for _, value := range values {
			sum += value
		}

		if _, exists := ambiguity[sum]; !exists {
			ambiguity[sum] = make(map[string][]string)
		}
		ambiguity[sum][cases[key]] = append(ambiguity[sum][cases[key]], key)
	}

	var b bytes.Buffer
	for _, returnValues := range ambiguity {
		if len(returnValues) == 1 {
			// Not ambiguous, but count how many keys map to this
			// final state and return value.  If more than one,
			// delete all but the first, so that we don't output
			// duplicate case statements.
			var keys []string
			for returnValue := range returnValues {
				keys = returnValues[returnValue]
			}
			for i := 1; i < len(keys); i++ {
				delete(state.final, keys[i])
			}

			continue
		}

		if b.Len() == 0 {
			b.WriteString("ambiguous matches: ")
		} else {
			b.Write([]byte{';', ' '})
		}
		first := true
		for _, keys := range returnValues {
			for _, key := range keys {
				if !first {
					b.Write([]byte{',', ' '})
				} else {
					first = false
				}
				b.WriteString(strconv.Quote(key))
			}
		}
	}

	if b.Len() == 0 {
		return nil
	} else {
		return errors.New(b.String())
	}
}

// finalString returns a string representing the final state of each key.  To
// make the generated code slightly more readable, this consists of an
// expression summing each intermediate state value (in hex).
func (state *stateMachine) finalString(key string) string {
	var b bytes.Buffer
	for n, value := range state.final[key] {
		if n != 0 {
			b.WriteString(" + ")
		}
		b.WriteString(fmt.Sprintf("0x%x", value))
	}
	return b.String()
}

// Generate outputs Go code to compare a string to a set of possible matches
// which are known at compile-time.
//
// Each entry in the map consists of a possible match as the key, and the
// corresponding expression to return as the value.  none is the expression to
// return if no match is found.
//
// Code to perform the match is written to the supplied io.Writer.  Before
// calling this function, the caller is expected to write the method signature
// and any input pre-processing logic.  The string to examine should be in a
// variable named "input".
//
// If flags are specified, it's possible to generate ambiguous code, in which
// the same input string will match multiple entries in the cases map, with
// different return values.  This function attempts to detect this and will
// return an error if ambiguity is detected.
//
// An error is also returned if the provided io.Writer is invalid, or if there
// are too many matches to fit within our uint64 state machine.
//
// The output is not buffered, and will be incomplete if an error is
// returned.  If the caller cares about this, they should have a way to
// discard the written output on error.
//
// Example usage:
//
//	fmt.Fprintln(w, "func matchFoo(input string) int {")
//	fastmatch.Generate(w, map[string]string{
//		"foo": "1",
//		"bar": "2",
//		"baz": "3",
//	}, "-1", fastmatch.Insensitive)
func Generate(w io.Writer, cases map[string]string, none string, flags ...*flag) error {
	equiv := makeRuneEquivalents(flags...)

	// Search is partitioned based on the length of the input.  Split
	// cases into each possible search space:
	keys := make(map[int][]string)
	for key := range cases {
		keys[len(key)] = append(keys[len(key)], key)
	}
	lengths := make([]int, 0, len(keys))
	for len := range keys {
		lengths = append(lengths, len)
	}
	sort.Ints(lengths)

	if _, err := fmt.Fprintln(w, "\tswitch len(input) {"); err != nil {
		// We only check fmt.Fprint return value on the first write.
		// Hopefully this is sufficient.
		return err
	}
	for _, l := range lengths {
		state := newStateMachine(keys[l])

		fmt.Fprintf(w, "\tcase %d:", l)
		fmt.Fprintln(w)
		fmt.Fprintln(w, "\t\tvar state uint64")

		for offset := 0; offset < l; offset++ {
			// Make a sorted list (sans duplicates) of possible
			// runes at this offset:
			runes := sortableRunes(make([]rune, 0, len(keys[l])))
			runesSeen := make(map[rune]bool, len(keys[l]))
		possibilities:
			for _, key := range keys[l] {
				r := rune(key[offset])
				for _, r2 := range equiv.lookup(r) {
					if runesSeen[r2] {
						continue possibilities
					}
					runesSeen[r2] = true
				}
				runes = append(runes, r)
			}
			sort.Sort(runes)

			// Assign a unique state value to each possible rune
			// (including equivalents):
			state.shift()
			runeStates := make(map[rune]uint64, len(keys[l]))
			for _, r := range runes {
				runeStates[r] = state.next
				for _, key := range keys[l] {
					for _, r2 := range equiv.lookup(r) {
						if rune(key[offset]) == r2 {
							state.accumulate(key)
							break
						}
					}
				}
				if err := state.increment(); err != nil {
					return err
				}
			}

			// Output code which increments state based on which
			// rune (or equivalent) was seen:
			fmt.Fprintf(w, "\t\tswitch input[%d] {", offset)
			fmt.Fprintln(w)
			for _, r := range runes {
				fmt.Fprint(w, "\t\tcase ")
				for n, r2 := range equiv.lookup(r) {
					if n != 0 {
						fmt.Fprint(w, ", ")
					}
					fmt.Fprintf(w, "'%c'", r2)
				}
				fmt.Fprintln(w, ":")
				fmt.Fprintf(w, "\t\t\tstate += 0x%x", runeStates[r])
				fmt.Fprintln(w)
			}
			fmt.Fprintln(w, "\t\tdefault:")
			fmt.Fprintln(w, "\t\t\treturn", none)
			fmt.Fprintln(w, "\t\t}")
		}

		// Now output code to compare actual state to possible final
		// values:
		if err := state.checkAmbiguity(cases); err != nil {
			return err
		}
		fmt.Fprintln(w, "\t\tswitch state {")
		for key := range state.final {
			fmt.Fprintf(w, "\t\tcase %s:", state.finalString(key))
			fmt.Fprintln(w)
			fmt.Fprintln(w, "\t\t\treturn", cases[key])
		}
		fmt.Fprintln(w, "\t\t}")
	}
	fmt.Fprintln(w, "\t}")
	fmt.Fprintln(w, "\treturn", none)
	fmt.Fprintln(w, "}")

	return nil
}

// GenerateReverse outputs Go code that returns the string value for a given
// match.  The result from the generated function will be the reverse of that
// from a function generated with Generate.
//
// If the supplied io.Writer is not valid, or if more than one string maps to
// the same value, an error is returned.
//
// This function accepts flags (in order to match Generate's function
// signature), but they are currently ignored.
func GenerateReverse(w io.Writer, cases map[string]string, none string, _ ...*flag) error {
	keys := make([]string, 0, len(cases))
	for key := range cases {
		keys = append(keys, key)
	}
	sort.Strings(keys)

	if _, err := fmt.Fprintln(w, "\tswitch input {"); err != nil {
		return err
	}
	ambiguity := make(map[string][]string, len(cases))
	for _, key := range keys {
		ambiguity[cases[key]] = append(ambiguity[cases[key]], key)
		fmt.Fprintf(w, "\tcase %s:", cases[key])
		fmt.Fprintln(w)
		fmt.Fprintln(w, "\t\treturn", strconv.Quote(key))
	}

	var b bytes.Buffer
	for _, returnValues := range ambiguity {
		if len(returnValues) == 1 {
			continue
		}

		if b.Len() == 0 {
			b.WriteString("ambiguous values: ")
		} else {
			b.Write([]byte{';', ' '})
		}
		first := true
		for _, value := range returnValues {
			if !first {
				b.Write([]byte{',', ' '})
			} else {
				first = false
			}
			b.WriteString(strconv.Quote(value))
		}
	}
	if b.Len() != 0 {
		return errors.New(b.String())
	}

	fmt.Fprintln(w, "\tdefault:")
	fmt.Fprintln(w, "\t\treturn", none)
	fmt.Fprintln(w, "\t}")
	fmt.Fprintln(w, "}")

	return nil
}
